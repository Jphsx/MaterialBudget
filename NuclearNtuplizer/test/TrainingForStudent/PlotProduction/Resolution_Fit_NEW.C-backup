#include <TH2.h>
#include <TStyle.h>
#include <TCanvas.h>
#include <TGraph.h>
#include <TH1.h>
#include "TAxis.h"
#include <TMatrixD.h>
#include <iostream>     // std::cout
#include <algorithm>    // std::max
#include <TMath.h>
#include "Fit/BinData.h"
#include <TF1.h>
#include <TROOT.h>
#include <string>
#include <TMinuit.h>
#include <TLine.h>
#include <stdlib.h>

int getPrecision(double num)
{
 string num_str = std::to_string(num);
 num_str.erase ( num_str.find_last_not_of('0') + 1, std::string::npos );
 int pre = 0;
 bool point = false;
 for(int i=0; i<num_str.length(); i++)
 {
  if(point)
  {
   pre++;
  }
  if(num_str.at(i) == '.')
  {
   point = true;
  }
 }
 return pre;
}

double toPrecision(double num, int n) 
{
    //https://stackoverflow.com/questions/202302/rounding-to-an-arbitrary-number-of-significant-digits

    if(num == 0) {
      return 0.0;
    }

    double d = std::ceil(std::log10(num < 0 ? -num : num));
    int power = n - (int)d;
    double magnitude = std::pow(10., power);
    long shifted = ::round(num*magnitude);

    std::ostringstream oss;
    oss << shifted/magnitude;
    string num_str = oss.str();
    return atof(num_str.c_str());
}

void Rounding(double sigma68_abs_err, double sigma68_rel_err, double sigma68, TString& landau_sigma68_tstr, TString& landau_rel_err_tstr)
{
  string landau_sigma68_start = "Landau #sigma68% = ";
  char landau_sigma68_char[50];
  char landau_sigma68_err_char[50];
  string pm = " #pm ";
  string units = " #mum";
  string landau_rel_err = "Relative Error = ";
  string format_sprintf = "%.";
  format_sprintf+="lf";
 if(sigma68_abs_err > 0.001)
 {
  sigma68_abs_err = toPrecision(sigma68_abs_err,2);
  int precision =  getPrecision(sigma68_abs_err); //get number of places after decimal point
  sigma68 = toPrecision(sigma68,precision);
  sigma68=sigma68*10000.0;
  sigma68_abs_err=sigma68_abs_err*10000.0;
  precision = getPrecision(sigma68_abs_err);
  string precision_str = std::to_string(precision);
  format_sprintf+=precision_str;
 
  sprintf(landau_sigma68_char, format_sprintf.c_str(), sigma68);
 

  sprintf(landau_sigma68_err_char, format_sprintf.c_str(), sigma68_abs_err);

  landau_sigma68_start += landau_sigma68_char;
  landau_sigma68_start += pm;
  landau_sigma68_start += landau_sigma68_err_char; 
  landau_sigma68_start += units; 
  landau_sigma68_tstr = landau_sigma68_start;
 }
 else
 {
  sigma68_abs_err = toPrecision(sigma68_abs_err,1);
  int precision =  getPrecision(sigma68_abs_err); //get number of places after decimal point
  sigma68 = toPrecision(sigma68,precision);
  sigma68=sigma68*10000.0;
  sigma68_abs_err=sigma68_abs_err*10000.0;
  precision = getPrecision(sigma68_abs_err);
  string precision_str = std::to_string(precision);
  format_sprintf+=precision_str;
 
  sprintf(landau_sigma68_char, format_sprintf.c_str(), sigma68);
 
  sprintf(landau_sigma68_err_char, format_sprintf.c_str(), sigma68_abs_err);

  landau_sigma68_start += landau_sigma68_char;
  landau_sigma68_start += pm;
  landau_sigma68_start += landau_sigma68_err_char; 
  landau_sigma68_start += units; 
  landau_sigma68_tstr = landau_sigma68_start; 
 }
  char landau_sigma68_rel_char[50];
  sprintf(landau_sigma68_rel_char, "%.1lf", sigma68_rel_err*100.0);
  landau_rel_err+=landau_sigma68_rel_char;
  string per = "%";
  landau_rel_err+=per;
  landau_rel_err_tstr = landau_rel_err;
}

Double_t Fit_Landau(Double_t *x,Double_t *par)
{
 double norm = par[0];
 double mean = par[1];
 double sigma = par[2];

 return norm*TMath::Landau(x[0]-mean,sigma,0);
}

Double_t Fit_Cauchy(Double_t *x,Double_t *par)
{
   Double_t pi = TMath::Pi();
   Double_t norm = par[0];
   Double_t x0 = par[1];
   Double_t b = par[2];
   return norm*(b/(pi * ((x[0]-x0)*(x[0]-x0) + b*b)));
}

double GammaCalc(TH1* hist, TF1* func, double PerpendicularFactor)
{
 double widthTest=0.0;
 double width=0.0;
 double widthP=0.0; //Gamma
 double range=100.0;
 int counts=0;
 std::cout <<"Max Landau/histo Value/2 = " << hist->GetMaximum()/2.0 << std::endl;
 for(int i=0; i<hist->GetMaximum()*100000; i++)
 {
  //break;
  if(i%100000==0)
  {
   //std::cout << "Looped Through: " << i*0.00001 << std::endl;
  }
  widthTest=func->Eval((i)*0.00001);
  if(widthTest<=((hist->GetMaximum()/2.0)+1.0/range) && widthTest>=((hist->GetMaximum()/2.0)-1.0/range))
  {
   widthP=i*0.00001; //Gamma
   counts++;
  }
  if(counts>0) break;
 }
 width=func->Eval(widthP);
 std::cout << "Width Value Checker  = " << width << std::endl;
 double integral=func->Integral(0.,100.0/PerpendicularFactor);
 std::cout << "Integral(0->100.0)=" << integral << std::endl;
 return widthP;
}

double sigma68calc(TF1* fit, TH1* hist, double PerpendicularFactor)
{
 //calculate sigma at 68% for landau
 double integral=fit->Integral(0.,100.0/PerpendicularFactor);
 double sigmaTest=0.0;
 double integralTest=0.0;
 double sigma68=0.0;
 int count=0;
 double sigma68value=integral*0.68;
 //std::cout << "68% of integral from 0->100.0 = " << sigma68value << std::endl;
 double ranges=1000.0;
 for(int i=0; i<hist->GetMaximum()*10000000; i++)
 { 
  //break;
  sigmaTest=i*0.000001;
  //if(sigmaTest>1.0/PerpendicularFactor) break;
  //if(sigmaTest<widthP) continue;
  integralTest=fit->Integral(0.0,sigmaTest);
  /*if(i%10000 == 0 )
  {
   std::cout << "Looped Through sigma = " << sigmaTest << std::endl;
  }*/
  if(integralTest<=(sigma68value+1.0/ranges) && integralTest>=(sigma68value-1.0/ranges))
  {
   count++;
   sigma68=sigmaTest;
  }
  if(count>0) break;
  }
 sigma68 = abs(sigma68);
 return sigma68;
}

double sigma68errcalc(TF1* fit,TH1* hist,double sigma68,double PerpendicularFactor)
{
 TF1* fit_copy = fit;
 
 //cout << "sigma 68 orig: " << sigma68 << endl;
 double par0 = fit->GetParameter(0);
 double par1 = fit->GetParameter(1);
 double par2 = fit->GetParameter(2);
 
 double par0err = fit->GetParError(0);
 double par1err = fit->GetParError(1);
 double par2err = fit->GetParError(2);
 
 fit_copy->FixParameter(0,par0);
 fit_copy->FixParameter(1,par1);
 fit_copy->FixParameter(2,par2);
 //double sigma68_check = sigma68calc(fit_copy,hist,PerpendicularFactor);
 //cout << "sigma68 unchanged: " << sigma68_check << endl;

 fit_copy->FixParameter(1,par1+par1err);
 double sigma68_MPV_plus = sigma68calc(fit_copy,hist,PerpendicularFactor);
 //cout << "sigma68 MPV Plus: " << sigma68_MPV_plus << endl; 
 
 fit_copy->FixParameter(1,par1-par1err);
 double sigma68_MPV_minus = sigma68calc(fit_copy,hist,PerpendicularFactor);
 //cout << "sigma68 MPV Minus: " << sigma68_MPV_minus << endl; 

 fit_copy->FixParameter(1,par1);
 
 fit_copy->FixParameter(2,par2+par2err);
 double sigma68_sigma_plus = sigma68calc(fit_copy,hist,PerpendicularFactor);
 //cout << "sigma68 sigma Plus: " << sigma68_sigma_plus << endl; 

 fit_copy->FixParameter(2,par2-par2err);
 double sigma68_sigma_minus = sigma68calc(fit_copy,hist,PerpendicularFactor);
 //cout << "sigma68 Sigma Minus: " << sigma68_sigma_minus << endl; 
 
 double delta_sigma68_MPV_plus = abs(sigma68-sigma68_MPV_plus);
 //cout << "Delta Sigma68 MPV Plus: " << delta_sigma68_MPV_plus << endl;
 
 double delta_sigma68_MPV_minus = abs(sigma68-sigma68_MPV_minus);
 //cout << "Delta Sigma68 MPV Minus: " << delta_sigma68_MPV_minus << endl;
 
 double delta_sigma68_sigma_plus = abs(sigma68-sigma68_sigma_plus);
 //cout << "Delta Sigma68 sigma Plus: " << delta_sigma68_sigma_plus << endl;
 
 double delta_sigma68_sigma_minus = abs(sigma68-sigma68_sigma_minus);
 //cout << "Delta Sigma68 sigma Minus: " << delta_sigma68_sigma_minus << endl;
 
 double delta_MPV_max, delta_sigma_max, MPV_min, sigma_min;
 
 if(delta_sigma68_MPV_plus > delta_sigma68_MPV_minus)
 {
  delta_MPV_max = delta_sigma68_MPV_plus;
 }
 else
 {
  delta_MPV_max = delta_sigma68_MPV_minus;
 }

 if(delta_sigma68_sigma_plus > delta_sigma68_sigma_minus)
 {
  delta_sigma_max = delta_sigma68_sigma_plus;
 }
 else
 {
  delta_sigma_max = delta_sigma68_sigma_minus;
 }
 
 if(sigma68_MPV_plus < sigma68_MPV_minus)
 {
  MPV_min = sigma68_MPV_plus;
 }
 else
 {
  MPV_min = sigma68_MPV_minus;
 }
 if(MPV_min == 0.0 && MPV_min == sigma68_MPV_plus)
 {
  MPV_min = sigma68_MPV_minus;
 }
 else if(MPV_min == 0.0 && MPV_min == sigma68_MPV_minus)
 {
  MPV_min = sigma68_MPV_plus;
 }

 if(sigma68_sigma_plus < sigma68_sigma_minus)
 {
  sigma_min = sigma68_sigma_plus;
 }
 else
 {
  sigma_min = sigma68_sigma_minus;
 }
 if(sigma_min == 0.0 && sigma_min == sigma68_sigma_plus)
 {
  sigma_min = sigma68_sigma_minus;
 }
 else if(sigma_min == 0.0 && sigma_min == sigma68_sigma_minus)
 {
  sigma_min = sigma68_sigma_plus;
 }

 //cout << "delta_MPV_max: " << delta_MPV_max << endl;
 //cout << "delta_sigma_max: " << delta_sigma_max << endl;
 //cout << "MPV_min: " << MPV_min << endl;
 //cout << "sigma_min: " << sigma_min << endl;


 double sigma68_rel_err = sqrt((delta_MPV_max/MPV_min)*(delta_MPV_max/MPV_min)+(delta_sigma_max/sigma_min)*(delta_sigma_max/sigma_min)); //relative error 
 return sigma68_rel_err;
}
 
void LandauDrawing(TCanvas*& canvas, TH1* hist, double PerpendicularFactor, TF1* func, TString status_landau, string filename)
{
 canvas->Update();
 filename+=".png"; 

 TPaveStats *stats_landau = (TPaveStats*)hist->FindObject("stats");
 stats_landau->SetTextColor(kBlue);
 stats_landau->SetLineColor(kBlue);
 stats_landau->SetY1NDC(0.95);
 stats_landau->SetY2NDC(0.7);
 canvas->Update(); 
 
 TString status_landau_leg = "Landau Status = ";
 status_landau_leg+=status_landau;

 //double gamma = GammaCalc(hist, func, PerpendicularFactor);

 std::cout << "Calculating Landau Sigma 68%" << std::endl;
 double sigma68 = sigma68calc(func, hist, PerpendicularFactor);

 if(sigma68 == 0.0)
 {
  cout << "\033[1;31mCheck Landau\033[0m\n" << endl;
 }
 //std::cout << "sigma68: " << sigma68 << endl;

 std::cout << "Calculating Error on Landau Sigma 68%" << std::endl;

 double sigma68_rel_err = sigma68errcalc(func, hist, sigma68, PerpendicularFactor);
 double sigma68_abs_err = sigma68*sigma68_rel_err;
 //std::cout << "sigma68=" << sigma68*10000.0 << " um" << std::endl;
 //std::cout << "sigma68 absolute err=" << sigma68_abs_err*10000.0 << " um" << std::endl;
 //std::cout << "sigma68 relative err=" << sigma68_rel_err*100.0 << "%" << std::endl;


 TLine* landau_sigma_line = new TLine(sigma68,0.0,sigma68,func->Eval(sigma68));
 landau_sigma_line->SetLineColor(kBlue);
 landau_sigma_line->SetLineStyle(7);
 landau_sigma_line->SetLineWidth(2);
 landau_sigma_line->Draw("SAMES");
 canvas->Update();


 //rounding sigma68 and errrors
 TString landau_sigma68_tstr="";
 TString landau_rel_err_tstr="";
 Rounding(sigma68_abs_err,sigma68_rel_err,sigma68,landau_sigma68_tstr,landau_rel_err_tstr);
 
 canvas->Update();
 TLegend* leg_landau = new TLegend(0.62,0.6,0.98,0.7,"");
 leg_landau->SetFillColor(kWhite);
 leg_landau->SetTextColor(kBlue);
 leg_landau->AddEntry((TObject*)0, status_landau_leg, "");
 leg_landau->AddEntry((TObject*)0, landau_sigma68_tstr, "");
 leg_landau->AddEntry((TObject*)0, landau_rel_err_tstr, "");
 leg_landau->Draw("SAMES");
 
 canvas->Update();
 canvas->SaveAs(filename.c_str());
 cout << endl; 
}

TString FitOptionA(TH1* hist, TF1* func, double PerpendicularFactor, string filename)
{
 filename+="A";
 string canvasname = hist->GetName();
 canvasname += "_canvasA";
 TCanvas* canvas = new TCanvas((canvasname).c_str(),(canvasname).c_str(),750,500);
 canvas->cd();
 TH1* hist_clone = (TH1*)(hist->Clone());
 TF1* func_clone = new TF1("func_landau","landau");
 func_clone->SetLineColor(kBlue);
 func_clone->SetParameter(0,func->GetParameter(0));
 func_clone->SetParameter(1,func->GetParameter(1));
 func_clone->SetParameter(2,func->GetParameter(2));
 hist_clone->Fit(func_clone,"MR","",0.0,0.95*hist_clone->GetXaxis()->GetXmax());
 TString status_landau = gMinuit->fCstatu;
 LandauDrawing(canvas,hist_clone,PerpendicularFactor,func_clone,status_landau,filename);
 return status_landau;
}

TString FitOptionB(TH1* hist, TF1* func, double PerpendicularFactor, string filename)
{
 filename+="B";
 string canvasname = hist->GetName();
 canvasname += "_canvasB";
 TCanvas* canvas = new TCanvas((canvasname).c_str(),(canvasname).c_str(),750,500);
 canvas->cd();
 TH1* hist_clone = (TH1*)(hist->Clone());
 TF1* landau_fit = new TF1("func_landau","landau");
 landau_fit->SetLineColor(kBlue);
 landau_fit->SetParameter(0,0.5*hist_clone->GetNormFactor());
 landau_fit->SetParameter(1,0.0);
 landau_fit->SetParameter(2,0.08*hist_clone->GetRMS());
 hist_clone->Fit(landau_fit,"MR","SAMES",0.0,0.5*hist_clone->GetXaxis()->GetXmax());
 TString status_landau = gMinuit->fCstatu;
 LandauDrawing(canvas,hist_clone,PerpendicularFactor,landau_fit,status_landau,filename);
 return status_landau;
}

vector<TH1*> list_histos(const char *fname)
{
 std::vector<TH1*> vect_hist;
 TKey *key;
 TFile *f = TFile::Open(fname,"READ");
 if(!f || f->IsZombie())
 {
  cout << "Unable to open " << fname << " for reading..." << endl;
  return vect_hist;
 }
 TIter next((TList *)f->GetListOfKeys());
 while((key = (TKey *)next()))
 {
  TClass *cl = gROOT->GetClass(key->GetClassName());
  if(cl->InheritsFrom("TH1"))
  {
   TH1 *h = (TH1*)key->ReadObj();
   string name = h->GetName();
   vect_hist.push_back(h);
  }
 }
 return vect_hist;
}

void Results (std::vector<TString> vect_status_landau)//, std::vector<TString> vect_status_cauchy)
{
/*
cout << endl << "FIT RESULTS Cauchy" << endl;
int success_cauchy = 0;
int problems_cauchy = 0;
int failed_cauchy = 0;
int failure_cauchy = 0;
int call_limit_cauchy = 0;

for(int i=0; i<vect_status_cauchy.size(); i++)
{
 if(vect_status_cauchy[i] == "SUCCESSFUL")
 {
  success_cauchy++;
 }
 if(vect_status_cauchy[i] == "PROBLEMS  ")
 {
  problems_cauchy++;
 }
 if(vect_status_cauchy[i] == "FAILED    ")
 {
  failed_cauchy++;
 }
 if(vect_status_cauchy[i] == "FAILURE   ")
 {
  failure_cauchy++;
 }
 if(vect_status_cauchy[i] == "CALL LIMIT")
 {
  call_limit_cauchy++;
 }
}
 
 cout << "Total Successful fits = " << success_cauchy << "/" << vect_status_cauchy.size() << " or " << 100.0*(1.0*success_cauchy/vect_status_cauchy.size()) << "%" << endl;
 cout << "Total Problems fits = " << problems_cauchy << "/" << vect_status_cauchy.size() << " or " << 100.0*(1.0*problems_cauchy/vect_status_cauchy.size()) << "%" << endl;
 cout << "Total Failed fits = " << failed_cauchy << "/" << vect_status_cauchy.size() << " or " << 100.0*(1.0*failed_cauchy/vect_status_cauchy.size()) << "%" << endl;
 cout << "Total Failure fits = " << failure_cauchy << "/" << vect_status_cauchy.size() << " or " << 100.0*(1.0*failure_cauchy/vect_status_cauchy.size()) << "%" << endl; 
 cout << "Total Call Limit fits = " << call_limit_cauchy << "/" << vect_status_cauchy.size() << " or " << 100.0*(1.0*call_limit_cauchy/vect_status_cauchy.size()) << "%" << endl;
 cout << "Total Fits = " << success_cauchy+problems_cauchy+failed_cauchy+failure_cauchy+call_limit_cauchy << "/" << vect_status_cauchy.size() << endl;
 */

cout << endl << "FIT RESULTS Landau" << endl;
int success_landau = 0;
int problems_landau = 0;
int failed_landau = 0;
int failure_landau = 0;
int call_limit_landau = 0;

for(int i=0; i<vect_status_landau.size(); i++)
{
 if(vect_status_landau[i] == "SUCCESSFUL")
 {
  success_landau++;
 }
 if(vect_status_landau[i] == "PROBLEMS  ")
 {
  problems_landau++;
 }
 if(vect_status_landau[i] == "FAILED    ")
 {
  failed_landau++;
 }
 if(vect_status_landau[i] == "FAILURE   ")
 {
  failure_landau++;
 }
 if(vect_status_landau[i] == "CALL LIMIT")
 {
  call_limit_landau++;
 }
}
 cout << "Total Successful fits = " << success_landau << "/" << vect_status_landau.size() << " or " << 100.0*(1.0*success_landau/vect_status_landau.size()) << "%" << endl;
 cout << "Total Problems fits = " << problems_landau << "/" << vect_status_landau.size() << " or " << 100.0*(1.0*problems_landau/vect_status_landau.size()) << "%" << endl;
 cout << "Total Failed fits = " << failed_landau << "/" << vect_status_landau.size() << " or " << 100.0*(1.0*failed_landau/vect_status_landau.size()) << "%" << endl;
 cout << "Total Failure fits = " << failure_landau << "/" << vect_status_landau.size() << " or " << 100.0*(1.0*failure_landau/vect_status_landau.size()) << "%" << endl; 
 cout << "Total Call Limit fits = " << call_limit_landau << "/" << vect_status_landau.size() << " or " << 100.0*(1.0*call_limit_landau/vect_status_landau.size()) << "%" << endl;
 cout << "Total Number of Fits  = " << success_landau+problems_landau+failed_landau+failure_landau+call_limit_landau << "/" << vect_status_landau.size() << endl;
 
 cout << endl;

}


void Resolution_Fit_NEW(){

cout << endl << endl << endl << endl;
/*
ROOT::Math::MinimizerOptions::SetDefaultTolerance(1);
int numcalls = 10000;
ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls(numcalls);
*/
gROOT->Clear();
gStyle->SetOptStat(0);
gStyle->SetOptFit(1111);
gStyle->SetPalette(1);
gStyle->SetOptTitle(0);

const char *fname1 = "ResolutionPlots_10GeV_2018.root";
//const char *fname1 = "ResolutionPlots_2015.root";

// open file:
//bool FixMean=true;
bool FixMean=false;
std::vector<TH1*> vect_hist = list_histos(fname1);

std::vector<TCanvas*> vect_canvas;
std::vector<string> vect_filename;
std::vector<TString> vect_status_landau;
std::vector<TString> vect_status_landauA;
std::vector<TString> vect_status_landauB;
//std::vector<TString> vect_status_cauchy;

for (int i = 0; i < vect_hist.size(); i++)
{
 string canvasname = vect_hist[i]->GetName();
 canvasname += "_canvas";
 TCanvas* dummy_canvas = new TCanvas((canvasname).c_str(),(canvasname).c_str(),750,500);
 vect_canvas.push_back(dummy_canvas);
 string dir = "10GeV_2018_Results";
 //string dir = "2015_Results";
 if(FixMean)
 {
  dir+="_ZeroMean/";
 }
 else
 {
  dir+="_Default/";
 }
 string filename = vect_hist[i]->GetName();
 dir += filename;
 vect_filename.push_back(dir);
}

for (int i = 0; i < vect_hist.size(); i++)
{
 vect_hist[i]->GetXaxis()->SetTitle("DeltaR [cm]");
 vect_hist[i]->GetYaxis()->SetTitle("Number Of Events");
 vect_hist[i]->SetLineColor(kBlack);
 vect_canvas[i]->cd();
 cout << endl << "Fitting " << vect_hist[i]->GetName() << "   (" << i+1 << "/27)" << endl;
 const char* histname = vect_hist[i]->GetName();
 string histname_str = histname;
 string perp = "Perpendicular";
 double PerpendicularFactor;
 if(histname_str.find(perp) != std::string::npos)
 {
  PerpendicularFactor=10.0;
 }
 else
 {
  PerpendicularFactor=1.0;
 }
//Landau
 cout << endl << "Fit Landau" << endl;
 TH1* vect_hist_clone = (TH1*)(vect_hist[i]->Clone());
 //vect_hist_clone->Fit("landau","EMR","SAMES",0.,0.95/PerpendicularFactor); //default fit
 //TF1* landau_fit = (TF1*)vect_hist_clone->GetFunction("landau");

 //fix MPV of Landau to 0
 TF1* landau_fit = new TF1("func_landau","landau");//,0.0,0.95/PerpendicularFactor);
 landau_fit->SetLineColor(kBlue);
 landau_fit->SetParameter(0,0.5*vect_hist_clone->GetNormFactor());
 if(FixMean)
 {
  landau_fit->FixParameter(1,0.0);
 }
 else
 {
  landau_fit->SetParameter(1,0.0);
 }
 landau_fit->SetParameter(2,0.08*vect_hist_clone->GetRMS());
 vect_hist_clone->Fit(landau_fit,"MR","SAMES",0.0,0.95*vect_hist_clone->GetXaxis()->GetXmax());
 
 TString status_landau = gMinuit->fCstatu;
 vect_status_landau.push_back(status_landau);
 LandauDrawing(vect_canvas[i],vect_hist_clone,PerpendicularFactor,landau_fit,status_landau,vect_filename[i]);

 cout << "Redoing Fit with Option A" << endl; 
 TString optionA = FitOptionA(vect_hist_clone,landau_fit,PerpendicularFactor,vect_filename[i]);
 vect_status_landauA.push_back(optionA);
 cout << "Redoing Fit with Option B" << endl; 
 TString optionB = FitOptionB(vect_hist_clone,landau_fit,PerpendicularFactor,vect_filename[i]);
 vect_status_landauB.push_back(optionB);
 
 //Cauchy
 /*
 TF1 *func = new TF1("func", Fit_Cauchy, 0.0, 0.95*vect_hist[i]->GetXaxis()->GetXmax(), 3);
 
 func->SetParameter(0,0.5*vect_hist[i]->GetNormFactor());
 if(FixMean)
 {
  func->FixParameter(1,0.0);
 }
 else
 {
  func->SetParameter(1,0.0);
 }
 func->SetParameter(2,0.07*vect_hist[i]->GetRMS());

 //func->SetParLimits(0,0.0,10000.0);
 //func->SetParLimits(1,-1.0,0.5/PerpendicularFactor);
 func->SetParLimits(2,0.0,10.0);

 func->SetParName(0,"norm");
 func->SetParName(1,"mean");
 func->SetParName(2,"gamma");

 vect_hist[i]->SetLineColor(kBlack);

 //cout << endl << "Fit Cauchy" << endl;

 //func->SetLineColor(kRed); 
 //func->SetLineColorAlpha(kRed,0.0); 
 //vect_hist[i]->Fit(func,"QEMR");

 //TString status_cauchy = gMinuit->fCstatu;
 //vect_status_cauchy.push_back(status_cauchy);

 //func->Draw("SAMES");

 vect_canvas[i]->Update();

 TPaveStats *stats_cauchy = (TPaveStats*)vect_hist[i]->GetListOfFunctions()->FindObject("stats");
 stats_cauchy->SetTextColor(kRed);
 stats_cauchy->SetLineColor(kRed);
 stats_cauchy->SetY1NDC(0.9);
 stats_cauchy->SetY2NDC(0.7);
 //stats_cauchy->Draw("SAMES");
 vect_canvas[i]->Update(); 
*/
 //TString status_cauchy_leg = "Cauchy Status = ";
 //status_cauchy_leg+=status_cauchy;

/* double cauchy_sigma68 = abs(func->GetParameter(2)*TMath::Tan(0.34*TMath::Pi())+func->GetParameter(1));
//if(cauchy_sigma68 > (1.0/PerpendicularFactor))
if(cauchy_sigma68 == 0.0)
{
 cout << "\033[1;31mCheck Cauchy\033[0m\n " << cauchy_sigma68 << endl;
}

//cout << "Cauchy Sigma68 = " << cauchy_sigma68 << endl;

TLine* cauchy_sigma_line = new TLine(cauchy_sigma68,0.0,cauchy_sigma68,func->Eval(cauchy_sigma68));
cauchy_sigma_line->SetLineColor(kRed);
cauchy_sigma_line->SetLineStyle(2);
cauchy_sigma_line->SetLineWidth(2);
//cauchy_sigma_line->Draw("SAMES");
vect_canvas[i]->Update();

TLine* cauchy_gamma_line = new TLine(func->GetParameter(2),0.0,func->GetParameter(2),func->Eval(func->GetParameter(2)));
cauchy_gamma_line->SetLineColor(kGreen+2);
cauchy_gamma_line->SetLineStyle(5);
cauchy_gamma_line->SetLineWidth(2);
cauchy_gamma_line->Draw("SAMES");
vect_canvas[i]->Update();
*/
 //string cauchy_sigma68_start = "Cauchy #sigma68% = ";

 //char cauchy_sigma68_char[50];
 //sprintf(cauchy_sigma68_char, "%.0lf", cauchy_sigma68*10000.0);
/*
  cauchy_sigma68_start += cauchy_sigma68_char;
  cauchy_sigma68_start += units; 
  TString cauchy_sigma68_tstr = cauchy_sigma68_start;
 */
/*
  TLegend* leg_cauchy = new TLegend(0.55,0.3,0.98,0.4,"");
  leg_cauchy->SetTextFont(42);
  leg_cauchy->SetTextSize(0.04);
  leg_cauchy->SetFillColor(kWhite);
  leg_cauchy->SetTextColor(kRed);
  leg_cauchy->AddEntry((TObject*)0, status_cauchy_leg, "");
  leg_cauchy->AddEntry((TObject*)0, cauchy_sigma68_tstr, "");
  leg_cauchy->Draw("SAMES");
 */
}
 cout << "Default Fit Results" << endl;
 Results(vect_status_landau);//, vect_status_cauchy);
 cout << "Option A Results" << endl;
 Results(vect_status_landauA);
 cout << "Option B Results" << endl;
 Results(vect_status_landauB);
}

